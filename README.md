# HUAWEISoftware2017
the java program of Huawei Software2017. I will push all of my versions, so if you want, you can know how I review my algorithm. 
We get Top64 of Dongbei and Jingjin regoin~~

版本有点多所以有点乱！
是的！
我也是这么觉得！

如果，你问我是不是每次的版本更新都使效果变好了。
那答案当然是否定的。

比赛的时候我要准备学校的一个专场演出（我是一个有点low的吉他手 哈哈），所以很忙，队友更忙，所以，这个程序是我在前面的偶尔和后面几天的突击写出来的。

最后队友贡献出的trick：删除特定节点 也是提升了结果

最终进了京津东北赛区的TOP64，拿到了华为的面试绿卡

我还得到了华为的文化衫和公仔小原，哈哈

总体来说，程序主要的技术有以下几个：

SPFA--这个的JAVA实现，也是搞了我3天，最后的经验是，看人家理论的原文啊！虽然有点晦涩难懂，但准确，其实认真看的话半天也看懂了，然后根据大神的思想写程序。

改进的模拟退火算法--其实SPFA够优化的话，用遗传算法等减少陷入局部最优解比例的方法最好，但是我的SPFA很慢啊。。主要就是要熟悉各种优化算法的优缺点，
                  然后综合选择，这种优化算法感觉数学建模啥的挺常用的，所以也没啥好说的，虽然改进的一些，但我相信你们会比我改进的好！
                  
算是一个trick：因为我的SPFA很慢，导致在高级样本的时候无法通过模拟退火收敛。于是，我就在最开始的时候不是每次删除一个，而是2个，3个，甚至到10个。
              这样做虽然使程序在高级样本上效果有很大提升，但是针对中低级样本却万万不可用。
              至于为什么，问一个机器学习的问题，BOOSTING不是每次拟合上一步的残差嘛，那为啥他的优点之一还有防止过拟合？
              答案是“因为小步逼近会比大步前行防止过拟合，所以BOOSTING相对来说具有防止过拟合的特性（但肯定不如BAGGING啦）”
              不懂BOOSTING和BAGGING之类的机器学习问题也不要紧，你只需要知道，这样的大步前行策略会加速高级用例优化算法收敛，但是对于中低级用例来说，
              很容易让他们陷入到很差的局部最优解，或者，甚至会导致结果在最优解（哪怕是局部最优解）的两端跳跃，而无法收敛到最优。
